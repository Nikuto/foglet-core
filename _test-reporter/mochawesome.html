<!doctype html>
<html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{&quot;stats&quot;:{&quot;suites&quot;:13,&quot;tests&quot;:28,&quot;passes&quot;:28,&quot;pending&quot;:0,&quot;failures&quot;:0,&quot;start&quot;:&quot;2018-10-02T11:54:45.163Z&quot;,&quot;end&quot;:&quot;2018-10-02T11:55:27.593Z&quot;,&quot;duration&quot;:42430,&quot;testsRegistered&quot;:28,&quot;passPercent&quot;:100,&quot;pendingPercent&quot;:0,&quot;other&quot;:0,&quot;hasOther&quot;:false,&quot;skipped&quot;:0,&quot;hasSkipped&quot;:false,&quot;passPercentClass&quot;:&quot;success&quot;,&quot;pendingPercentClass&quot;:&quot;danger&quot;},&quot;suites&quot;:{&quot;uuid&quot;:&quot;5b3d3b37-719d-4b31-b3ca-3c0485467133&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;b3b6df6b-2bde-476b-8c3b-8c385b15862f&quot;,&quot;title&quot;:&quot;Foglet High-level communication&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-communication-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-communication-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should send messages to a neighbour using unicast&quot;,&quot;fullTitle&quot;:&quot;Foglet High-level communication should send messages to a neighbour using unicast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2036,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf2.onUnicast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  assert.equal(message, &#x27;hello&#x27;)\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    console.log(peers)\n    assert.equal(peers.length, 1)\n    console.log(peers)\n    for (let i = 0; i &lt; peers.length; i++) {\n      f1.sendUnicast(peers[i], &#x27;hello&#x27;)\n    }\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;e900c813-eea2-4725-b7d9-465133167564&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should send messages to several neighbours using multicast&quot;,&quot;fullTitle&quot;:&quot;Foglet High-level communication should send messages to several neighbours using multicast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2011,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet wanted = 0\nlet received = 0\nfunction receive (id, message) {\n  received++\n  assert.equal(id, f1.outViewID)\n  assert.equal(message, &#x27;hello&#x27;)\n  if (received &gt;= wanted) {\n    utils.clearFoglets(foglets).then(() =&gt; done())\n  }\n}\nf2.onUnicast(receive)\nf3.onUnicast(receive)\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(() =&gt; {\n    const peers = f1.getNeighbours()\n    wanted = peers.length\n    f1.sendMulticast(peers, &#x27;hello&#x27;)\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;f1a4b09b-a72b-425f-96b6-bcde3ca7c621&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should send messages to all peers using broadcast in a network with 2 peers&quot;,&quot;fullTitle&quot;:&quot;Foglet High-level communication should send messages to all peers using broadcast in a network with 2 peers&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2011,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nlet neighbourID = null\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf2.onBroadcast((id, data) =&gt; {\n  assert.equal(id, neighbourID)\n  assert.equal(data, &#x27;hello&#x27;)\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  neighbourID = f1.outViewID\n  setTimeout(function () {\n    f1.sendBroadcast(&#x27;hello&#x27;)\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;7f0b76b4-4f12-4cce-988c-16c9c21adb97&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should simply send messages to all peers using broadcast in a 3 peers network&quot;,&quot;fullTitle&quot;:&quot;Foglet High-level communication should simply send messages to all peers using broadcast in a 3 peers network&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2010,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet cptA = 0\nlet cptB = 0\nconst results = [ &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27; ]\nconst totalResult = 8\nconst check = utils.doneAfter(totalResult, () =&gt; {\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  f2.onBroadcast((id, message) =&gt; {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptA])\n    cptA++\n    check()\n  })\n  f3.onBroadcast((id, message) =&gt; {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptB])\n    cptB++\n    check()\n  })\n  setTimeout(() =&gt; {\n    f1.sendBroadcast(&#x27;1&#x27;)\n    f1.sendBroadcast(&#x27;2&#x27;)\n    f1.sendBroadcast(&#x27;3&#x27;)\n    f1.sendBroadcast(&#x27;4&#x27;)\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;4bf60181-3816-4493-8e53-ee0609c2632c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should receive broadcasted classically ordered messages in a 3 peers network (1-2-3-4)&quot;,&quot;fullTitle&quot;:&quot;Foglet High-level communication should receive broadcasted classically ordered messages in a 3 peers network (1-2-3-4)&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2011,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet cptA = 0\nlet cptB = 0\nconst results = [ &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27; ]\nconst totalResult = 8\nconst check = utils.doneAfter(totalResult, () =&gt; {\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  f2.onBroadcast((id, message) =&gt; {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptA])\n    cptA++\n    check()\n  })\n  f3.onBroadcast((id, message) =&gt; {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptB])\n    cptB++\n    check()\n  })\n  setTimeout(() =&gt; {\n    const id1 = f1.overlay().communication.sendBroadcast(&#x27;1&#x27;)\n    const id2 = f1.overlay().communication.sendBroadcast(&#x27;2&#x27;, null, id1)\n    const id3 = f1.overlay().communication.sendBroadcast(&#x27;3&#x27;, null, id2)\n    f1.overlay().communication.sendBroadcast(&#x27;4&#x27;, null, id3)\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;6fd06173-0e86-460c-bf4d-543b7a6308fc&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should receive broadcasted weirdly ordered messages in a 3 peers network (1-3-2-4)&quot;,&quot;fullTitle&quot;:&quot;Foglet High-level communication should receive broadcasted weirdly ordered messages in a 3 peers network (1-3-2-4)&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:4014,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet cptA = 0\nlet cptB = 0\nconst results = [ &#x27;1&#x27;, &#x27;3&#x27;, &#x27;2&#x27;, &#x27;4&#x27; ]\nconst totalResult = 8\nconst check = utils.doneAfter(totalResult, () =&gt; {\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  f2.onBroadcast((id, message) =&gt; {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptA])\n    cptA++\n    check()\n  })\n  f3.onBroadcast((id, message) =&gt; {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptB])\n    cptB++\n    check()\n  })\n  setTimeout(() =&gt; {\n    const id1 = f1.overlay().communication.sendBroadcast(&#x27;1&#x27;)\n    const id2 = f1.overlay().communication.sendBroadcast(&#x27;2&#x27;, null, {e: id1.e, c: 3})\n    setTimeout(() =&gt; {\n      f1.overlay().communication.sendBroadcast(&#x27;3&#x27;, null, id1)\n      f1.overlay().communication.sendBroadcast(&#x27;4&#x27;, null, id2)\n    }, 2000)\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;f68bc7a7-5cfa-452d-b648-64a2a064dc6f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;e900c813-eea2-4725-b7d9-465133167564&quot;,&quot;f1a4b09b-a72b-425f-96b6-bcde3ca7c621&quot;,&quot;7f0b76b4-4f12-4cce-988c-16c9c21adb97&quot;,&quot;4bf60181-3816-4493-8e53-ee0609c2632c&quot;,&quot;6fd06173-0e86-460c-bf4d-543b7a6308fc&quot;,&quot;f68bc7a7-5cfa-452d-b648-64a2a064dc6f&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:14093,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;ace9dffe-7277-4ab4-8d41-30a578131f8b&quot;,&quot;title&quot;:&quot;[FOGLET] Other functions tests&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-main-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-main-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;[FOGLET] getRandomNeighbourId is in getNeighbours&quot;,&quot;fullTitle&quot;:&quot;[FOGLET] Other functions tests [FOGLET] getRandomNeighbourId is in getNeighbours&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:9,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  console.log(&#x27;Peers: &#x27;, f1.getNeighbours(), f2.getNeighbours())\n  console.log(&#x27;Random:&#x27;, f1.getRandomNeighbourId(), f2.getRandomNeighbourId())\n  assert.include(f1.getNeighbours(), f1.getRandomNeighbourId())\n  utils.clearFoglets(foglets).then(() =&gt; done())\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;4ace3e65-9d98-43e0-8d09-51f93f46fb3a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;4ace3e65-9d98-43e0-8d09-51f93f46fb3a&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:9,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;4ffc6d2b-841e-4cd7-b3b1-44885a4955bc&quot;,&quot;title&quot;:&quot;Middlewares&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-middleware-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-middleware-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should use middleware on broadcast&quot;,&quot;fullTitle&quot;:&quot;Middlewares should use middleware on broadcast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2019,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf1.use(simpleMiddleware)\nf2.use(simpleMiddleware)\nf2.onBroadcast((id, data) =&gt; {\n  assert.equal(data, &#x27;So Long and Thanks for all the Fish&#x27;)\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    f1.sendBroadcast(&#x27;So Long&#x27;)\n  }, 2000)\n})&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;02c14afa-9b86-4e3b-aa07-a972696318b7&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should use middleware on unicast&quot;,&quot;fullTitle&quot;:&quot;Middlewares should use middleware on unicast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2007,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf1.use(simpleMiddleware)\nf2.use(simpleMiddleware)\nf2.onUnicast((id, message) =&gt; {\n  assert.equal(message, &#x27;So Long and Thanks for all the Fish&#x27;)\n  utils.clearFoglets(foglets).then(() =&gt; done())\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    f1.sendUnicast(peers[0], &#x27;So Long&#x27;)\n  }, 2000)\n})&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;b821c802-8522-4942-bd82-468d7f050919&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;02c14afa-9b86-4e3b-aa07-a972696318b7&quot;,&quot;b821c802-8522-4942-bd82-468d7f050919&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4026,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;b0d9ccae-e49d-457f-8c8e-ea2565b5d180&quot;,&quot;title&quot;:&quot;Overlays&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-overlay-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-overlay-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should build a simple TMan-based overlay&quot;,&quot;fullTitle&quot;:&quot;Overlays should build a simple TMan-based overlay&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2078,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n    const [ f1, f2 ] = utils.buildFog(Foglet, 2, [\n      {\n        name: &#x27;test-overlay&#x27;,\n        class: TestOverlay,\n        options: {\n          protocol: &#x27;foglet-test-overlay&#x27;,\n          signaling: {\n            room: &#x27;foglet-test-overlay-room&#x27;,\n            address: &#x27;http://localhost:8000/&#x27;\n          }\n        }\n      }\n    ])\n    f1.overlay(&#x27;test-overlay&#x27;).communication.onUnicast((id, msg) =&gt; {\n      assert.equal(msg, &#x27;hello world!&#x27;)\n      console.log(&#x27;Got message from: &#x27;, id, msg)\n      done()\n    })\n    utils.overlayConnect(&#x27;test-overlay&#x27;, 2000, f1, f2)\n      .then(() =&gt; {\n        setTimeout(() =&gt; {\n          const neighbours = f2.overlay(&#x27;test-overlay&#x27;).network.getNeighbours()\n          assert.equal(neighbours.length, 1)\n          f2.overlay(&#x27;test-overlay&#x27;).communication.sendUnicast(neighbours[0], &#x27;hello world!&#x27;)\n        }, 2000)\n      }).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;6fc84116-0d70-45cb-a5fa-966a40403c1e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should create a internal communication channel correctly&quot;,&quot;fullTitle&quot;:&quot;Overlays should create a internal communication channel correctly&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2028,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n    const [ f1, f2 ] = utils.buildFog(Foglet, 2, [\n      {\n        name: &#x27;test-overlay-communication&#x27;,\n        class: TestOverlay,\n        options: {\n          protocol: &#x27;foglet-test-overlay-communication&#x27;,\n          signaling: {\n            address: &#x27;http://localhost:8000/&#x27;,\n            room: &#x27;foglet-test-overlay-communication-room&#x27;\n          }\n        }\n      }\n    ])\n    f1.overlay(&#x27;test-overlay-communication&#x27;).network.communication.onUnicast((id, msg) =&gt; {\n      assert.equal(msg, &#x27;hello world!&#x27;)\n      console.log(&#x27;Got message from: &#x27;, id, msg)\n      done()\n    })\n    utils.overlayConnect(&#x27;test-overlay-communication&#x27;, 2000, f1, f2)\n      .then(() =&gt; {\n        setTimeout(() =&gt; {\n          const neighbours = f2.overlay(&#x27;test-overlay-communication&#x27;).network.getNeighbours()\n          assert.equal(neighbours.length, 1)\n          f2.overlay(&#x27;test-overlay-communication&#x27;).network.communication.sendUnicast(neighbours[0], &#x27;hello world!&#x27;)\n        }, 2000)\n      }).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;e961e6a9-a443-4066-a3b9-4ca13a88cf2e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;6fc84116-0d70-45cb-a5fa-966a40403c1e&quot;,&quot;e961e6a9-a443-4066-a3b9-4ca13a88cf2e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4106,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;0eb9dc01-8cda-4b8c-86fb-7395a32768c2&quot;,&quot;title&quot;:&quot;FogletProtocol&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;4746faaf-58e4-4424-8d33-b289345eb8d8&quot;,&quot;title&quot;:&quot;#unicast&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;0c0e2743-ad5a-4ff8-9a37-9359bedece55&quot;,&quot;title&quot;:&quot;#communication&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should receive messages from remote services&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #unicast #communication should receive messages from remote services&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1009,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const expected = &#x27;Hello world!&#x27;\n        const p1 = new UnicastProtocol(f1)\n        const p2 = new UnicastProtocol(f2, (id, msg) =&gt; {\n          assert.equal(msg, expected)\n        }, () =&gt; {\n          utils.clearFoglets(foglets).then(() =&gt; done())\n        })\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], expected)\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;a27d62e2-6270-43c5-86ec-7cff62f49a9b&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow peers to reply to service calls&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #unicast #communication should allow peers to reply to service calls&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1012,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastProtocol(f1)\n        const p2 = new UnicastProtocol(f2, (id, msg, reply) =&gt; {\n          reply(msg + &#x27; world!&#x27;)\n        })\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], &#x27;Hello&#x27;)\n              .then(msg =&gt; {\n                assert.equal(msg, &#x27;Hello world!&#x27;)\n                utils.clearFoglets(foglets).then(() =&gt; done())\n              })\n              .catch(() =&gt; {\n                utils.clearFoglets(foglets).then(() =&gt; done())\n              })\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;dee4042f-7898-4b56-9fdc-3d9d4fbbbbe5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow peers to reject service calls&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #unicast #communication should allow peers to reject service calls&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1005,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastProtocol(f1)\n        const p2 = new UnicastProtocol(f2, (id, msg, reply, reject) =&gt; {\n          reject(msg + &#x27; world!&#x27;)\n        })\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], &#x27;Hello&#x27;)\n              .then(msg =&gt; {\n                utils.clearFoglets(foglets).then(() =&gt; done(new Error(&#x27;Message should have rejected but instead got reply with &#x27; + msg)))\n              })\n              .catch(msg =&gt; {\n                assert.equal(msg, &#x27;Hello world!&#x27;)\n                utils.clearFoglets(foglets).then(() =&gt; done())\n              })\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;5a3d9c6e-4216-4f83-91a1-84d9ef518ed7&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;a27d62e2-6270-43c5-86ec-7cff62f49a9b&quot;,&quot;dee4042f-7898-4b56-9fdc-3d9d4fbbbbe5&quot;,&quot;5a3d9c6e-4216-4f83-91a1-84d9ef518ed7&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:3026,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;c2de0e2f-95db-49ba-b19b-36374d62d514&quot;,&quot;title&quot;:&quot;#hooks&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should allow before hooks on send &amp; receive&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #unicast #hooks should allow before hooks on send &amp; receive&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1007,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        UnicastHookProtocol = defineProtocol(&#x27;unicast-protocol-with-hooks&#x27;)`\n          init\n          ${initProtocol}\n          get\n          ${function (service) {\n    service.is.unicast()\n    service.on.receive(function (id, msg) {\n      if (this._callback) this._callback(id, msg)\n      if (this._done) this._done()\n    })\n    service.before.send(function (msg) {\n      return msg + &#x27; and Thanks for&#x27;\n    })\n    service.before.receive(function (msg) {\n      return msg + &#x27; all the Fish&#x27;\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastHookProtocol(f1)\n        const p2 = new UnicastHookProtocol(f2, (id, msg) =&gt; {\n          assert.equal(msg, &#x27;So Long and Thanks for all the Fish&#x27;)\n        }, () =&gt; {\n          utils.clearFoglets(foglets).then(() =&gt; done())\n        })\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], &#x27;So Long&#x27;)\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;387f472b-7a81-46b4-aa91-26aba58c9ee4&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow after hooks on send &amp; receive&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #unicast #hooks should allow after hooks on send &amp; receive&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1007,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        const check = utils.doneAfter(2, () =&gt; {\n          utils.clearFoglets(foglets).then(() =&gt; done())\n        })\n        UnicastHookProtocol = defineProtocol(&#x27;unicast-protocol-with-hooks&#x27;)`\n          get\n          ${function (service) {\n    service.is.unicast()\n    service.on.receive(function () {})\n    service.after.send(function (msg) {\n      assert.equal(msg, &#x27;So Long&#x27;)\n      check()\n    })\n    service.after.receive(function (msg) {\n      assert.equal(msg, &#x27;So Long&#x27;)\n      check()\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastHookProtocol(f1)\n        const p2 = new UnicastHookProtocol(f2)\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], &#x27;So Long&#x27;)\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;0bb599bd-74d1-4b3b-aa59-ed51d10d0635&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;387f472b-7a81-46b4-aa91-26aba58c9ee4&quot;,&quot;0bb599bd-74d1-4b3b-aa59-ed51d10d0635&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:2014,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;33af13da-420c-4848-a3f5-1df03a9540d1&quot;,&quot;title&quot;:&quot;#broadcast&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;59a33fb0-fec8-4190-a60b-0859e84d401d&quot;,&quot;title&quot;:&quot;#communication&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should receive messages from remote services&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #broadcast #communication should receive messages from remote services&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1007,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const expected = &#x27;Hello world!&#x27;\n        const p1 = new BroadcastProtocol(f1)\n        const p2 = new BroadcastProtocol(f2, (id, msg) =&gt; {\n          assert.equal(msg, expected)\n        }, () =&gt; {\n          utils.clearFoglets(foglets).then(() =&gt; done())\n        })\n        utils.pathConnect(foglets, 2000).then(() =&gt; {\n          setTimeout(function () {\n            p1.get(expected)\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;d6ebb3b1-8b3b-4bec-b84b-d8f076c4cb3e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;d6ebb3b1-8b3b-4bec-b84b-d8f076c4cb3e&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:1007,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;bb18fd95-d19b-4f71-b7d0-7b74329a4322&quot;,&quot;title&quot;:&quot;#hooks&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-protocol-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should allow before hooks on send &amp; receive&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #broadcast #hooks should allow before hooks on send &amp; receive&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1007,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        BroadcastHookProtocol = defineProtocol(&#x27;broadcast-protocol-with-hooks&#x27;)`\n          init\n          ${initProtocol}\n          get\n          ${function (service) {\n    service.is.broadcast()\n    service.on.receive(function (id, msg) {\n      if (this._callback) this._callback(id, msg)\n      if (this._done) this._done()\n    })\n    service.before.send(function (msg) {\n      return msg + &#x27; and Thanks for&#x27;\n    })\n    service.before.receive(function (msg) {\n      return msg + &#x27; all the Fish&#x27;\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new BroadcastHookProtocol(f1)\n        const p2 = new BroadcastHookProtocol(f2, (id, msg) =&gt; {\n          assert.equal(msg, &#x27;So Long and Thanks for all the Fish&#x27;)\n        }, () =&gt; {\n          utils.clearFoglets(foglets).then(() =&gt; done())\n        })\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(&#x27;So Long&#x27;)\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;bfd4f2e8-d363-44df-9f72-c008853ff2f2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should allow after hooks on send &amp; receive&quot;,&quot;fullTitle&quot;:&quot;FogletProtocol #broadcast #hooks should allow after hooks on send &amp; receive&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:1007,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;done =&gt; {\n        const check = utils.doneAfter(2, () =&gt; {\n          utils.clearFoglets(foglets).then(() =&gt; done())\n        })\n        BroadcastHookProtocol = defineProtocol(&#x27;broadcast-protocol-with-hooks&#x27;)`\n          get\n          ${function (service) {\n    service.is.broadcast()\n    service.on.receive(function () {})\n    service.after.send(function (msg) {\n      assert.equal(msg, &#x27;So Long&#x27;)\n      check()\n    })\n    service.after.receive(function (msg) {\n      assert.equal(msg, &#x27;So Long&#x27;)\n      check()\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new BroadcastHookProtocol(f1)\n        const p2 = new BroadcastHookProtocol(f2)\n        utils.pathConnect(foglets, 2000, true).then(() =&gt; {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(&#x27;So Long&#x27;)\n          }, 1000)\n        })&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;97505827-0cc7-49ad-b886-b3c68613aa6f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;bfd4f2e8-d363-44df-9f72-c008853ff2f2&quot;,&quot;97505827-0cc7-49ad-b886-b3c68613aa6f&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:2014,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;d01a4cb7-ae94-47a6-835b-bc6dd6494df2&quot;,&quot;title&quot;:&quot;[SIGNALING] Direct/Signaling connections&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-signaling-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-signaling-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;direct connection, return true when connected&quot;,&quot;fullTitle&quot;:&quot;[SIGNALING] Direct/Signaling connections direct connection, return true when connected&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:6,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nutils.pathConnect(foglets, 2000).then((status) =&gt; {\n  assert.isOk(status, &#x27;Status Must be true.&#x27;)\n  utils.clearFoglets(foglets)\n  done()\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;5fdd2a9b-34fc-41cb-aada-742e23a3e79c&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;signaling connection alone, return true when connected&quot;,&quot;fullTitle&quot;:&quot;[SIGNALING] Direct/Signaling connections signaling connection alone, return true when connected&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:8,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 1, [], [{ url: &#x27;stun:global.stun.twilio.com:3478?transport=udp&#x27; }])\nconst f1 = foglets[0]\nf1.share()\nf1.connection().then((status) =&gt; {\n  assert.isOk(status, &#x27;Status Must be true.&#x27;)\n  utils.clearFoglets(foglets)\n  done()\n}).catch(e =&gt; {\n  done(e)\n})&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;bf0368ba-44bc-4b8f-b17a-6a7cdc16a28e&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;signaling connection (2 peers network), return true when connected&quot;,&quot;fullTitle&quot;:&quot;[SIGNALING] Direct/Signaling connections signaling connection (2 peers network), return true when connected&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:34,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2, [], [{ url: &#x27;stun:global.stun.twilio.com:3478?transport=udp&#x27; }])\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf1.onUnicast((id, msg) =&gt; {\n  assert.equal(msg, &#x27;ping&#x27;)\n  utils.clearFoglets(foglets)\n  done()\n})\nf1.share()\nf1.connection().then((status) =&gt; {\n  f2.share()\n  assert.isOk(status, &#x27;Status Must be true.&#x27;)\n  f2.connection().then((status) =&gt; {\n    assert.isOk(status, &#x27;Status Must be true.&#x27;)\n    assert.equal(f2.getNeighbours().length, 1)\n    f2.sendUnicast(f2.getNeighbours()[0], &#x27;ping&#x27;)\n  }).catch(done)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;b641ba70-9b47-4ba9-8774-63c0f8db2758&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;5fdd2a9b-34fc-41cb-aada-742e23a3e79c&quot;,&quot;bf0368ba-44bc-4b8f-b17a-6a7cdc16a28e&quot;,&quot;b641ba70-9b47-4ba9-8774-63c0f8db2758&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:48,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:20000},{&quot;uuid&quot;:&quot;70af4eca-df9c-4db5-b667-e1a93bcbff2b&quot;,&quot;title&quot;:&quot;Foglet streaming communication&quot;,&quot;fullFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/tests/foglet-streams-test.js&quot;,&quot;file&quot;:&quot;/tests/foglet-streams-test.js&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;should stream data to a neighbour using unicast&quot;,&quot;fullTitle&quot;:&quot;Foglet streaming communication should stream data to a neighbour using unicast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2018,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nlet acc = &#x27;&#x27;\nf2.onStreamUnicast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;data&#x27;, data =&gt; { acc += data })\n  message.on(&#x27;end&#x27;, () =&gt; {\n    assert.equal(acc, &#x27;Hello world!Family!&#x27;)\n    utils.clearFoglets(foglets)\n    done()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    const stream = f1.streamUnicast(peers[0])\n    stream.write(&#x27;Hello &#x27;)\n    stream.write(&#x27;world!&#x27;)\n    stream.write(&#x27;Family!&#x27;)\n    stream.end()\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;5c84eeda-f498-4097-96cc-452e373d3ff8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should stream trailing data to a neighbour using unicast&quot;,&quot;fullTitle&quot;:&quot;Foglet streaming communication should stream trailing data to a neighbour using unicast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2005,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf2.onStreamUnicast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;data&#x27;, () =&gt; null)\n  message.on(&#x27;end&#x27;, () =&gt; {\n    assert.equal(message.trailers.length, 1)\n    assert.equal(message.trailers[0], &#x27;Hello world!Family!&#x27;)\n    utils.clearFoglets(foglets)\n    done()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    const stream = f1.streamUnicast(peers[0])\n    stream.write(&#x27;foo&#x27;)\n    stream.addTrailer(&#x27;Hello world!Family!&#x27;)\n    stream.end()\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;7b05d01b-f403-4d01-a5e8-c9b348f42085&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should transmit an error through a stream when using unicast&quot;,&quot;fullTitle&quot;:&quot;Foglet streaming communication should transmit an error through a stream when using unicast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2007,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst check = utils.doneAfter(2, () =&gt; {\n  utils.clearFoglets(foglets)\n  done()\n})\nf2.onStreamUnicast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;error&#x27;, err =&gt; {\n    assert.equal(err, &#x27;Everything goes wrong!&#x27;)\n    check()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    const stream = f1.streamUnicast(peers[0])\n    stream.on(&#x27;error&#x27;, () =&gt; check())\n    stream.destroy(&#x27;Everything goes wrong!&#x27;)\n    stream.end()\n  }, 2000)\n})&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;40b5616e-0e92-4df1-9768-929e42448c41&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should stream data to all peers using broadcast in a network with 2 peers&quot;,&quot;fullTitle&quot;:&quot;Foglet streaming communication should stream data to all peers using broadcast in a network with 2 peers&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2009,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nlet acc = &#x27;&#x27;\nf2.onStreamBroadcast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;data&#x27;, data =&gt; { acc += data })\n  message.on(&#x27;end&#x27;, () =&gt; {\n    assert.equal(acc, &#x27;Hello world!Family!&#x27;)\n    utils.clearFoglets(foglets)\n    done()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() =&gt; {\n  setTimeout(function () {\n    const stream = f1.streamBroadcast()\n    stream.write(&#x27;Hello &#x27;)\n    stream.write(&#x27;world!&#x27;)\n    stream.write(&#x27;Family!&#x27;)\n    stream.end()\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;797ae6bb-da1a-4120-9a6e-2dbab89654a8&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should stream data to all peers using broadcast in a network with 3 peers&quot;,&quot;fullTitle&quot;:&quot;Foglet streaming communication should stream data to all peers using broadcast in a network with 3 peers&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2010,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet accA = &#x27;&#x27;\nlet accB = &#x27;&#x27;\nconst check = utils.doneAfter(2, () =&gt; {\n  utils.clearFoglets(foglets)\n  done()\n})\nf2.onStreamBroadcast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;data&#x27;, data =&gt; { accA += data })\n  message.on(&#x27;end&#x27;, () =&gt; {\n    assert.equal(accA, &#x27;Hello world!Family!&#x27;)\n    check()\n  })\n})\nf3.onStreamBroadcast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;data&#x27;, data =&gt; { accB += data })\n  message.on(&#x27;end&#x27;, () =&gt; {\n    assert.equal(accB, &#x27;Hello world!Family!&#x27;)\n    check()\n  })\n})\nutils.pathConnect(foglets, 1000).then(() =&gt; {\n  setTimeout(function () {\n    const stream = f1.streamBroadcast()\n    stream.write(&#x27;Hello &#x27;)\n    stream.write(&#x27;world!&#x27;)\n    stream.write(&#x27;Family!&#x27;)\n    stream.end()\n  }, 2000)\n}).catch(done)&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;dd2e38e0-bf36-4de0-8c8d-83732e3ab60a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;should transmit an error through a stream when using broadcast&quot;,&quot;fullTitle&quot;:&quot;Foglet streaming communication should transmit an error through a stream when using broadcast&quot;,&quot;timedOut&quot;:false,&quot;duration&quot;:2012,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;code&quot;:&quot;const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nconst check = utils.doneAfter(3, () =&gt; {\n  utils.clearFoglets(foglets)\n  done()\n})\nf2.onStreamBroadcast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;error&#x27;, err =&gt; {\n    assert.equal(err, &#x27;Everything goes wrong!&#x27;)\n    check()\n  })\n})\nf3.onStreamBroadcast((id, message) =&gt; {\n  assert.equal(id, f1.outViewID)\n  message.on(&#x27;error&#x27;, err =&gt; {\n    assert.equal(err, &#x27;Everything goes wrong!&#x27;)\n    check()\n  })\n})\nutils.pathConnect(foglets, 1000).then(() =&gt; {\n  setTimeout(function () {\n    const stream = f1.streamBroadcast()\n    stream.on(&#x27;error&#x27;, () =&gt; check())\n    stream.destroy(&#x27;Everything goes wrong!&#x27;)\n    stream.end()\n  }, 2000)\n})&quot;,&quot;err&quot;:{},&quot;isRoot&quot;:false,&quot;uuid&quot;:&quot;701df076-39be-47ac-9595-8f1e44b18f99&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;5c84eeda-f498-4097-96cc-452e373d3ff8&quot;,&quot;7b05d01b-f403-4d01-a5e8-c9b348f42085&quot;,&quot;40b5616e-0e92-4df1-9768-929e42448c41&quot;,&quot;797ae6bb-da1a-4120-9a6e-2dbab89654a8&quot;,&quot;dd2e38e0-bf36-4de0-8c8d-83732e3ab60a&quot;,&quot;701df076-39be-47ac-9595-8f1e44b18f99&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:12061,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:30000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:30000},&quot;copyrightYear&quot;:2018}" data-config="{&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;reportDir&quot;:&quot;./docs/_test-reporter&quot;,&quot;reportTitle&quot;:&quot;foglet-core&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;cdn&quot;:false,&quot;charts&quot;:true,&quot;enableCharts&quot;:true,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showPassed&quot;:true,&quot;showFailed&quot;:true,&quot;showPending&quot;:true,&quot;showSkipped&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;saveJson&quot;:true,&quot;saveHtml&quot;:true,&quot;dev&quot;:false,&quot;assetsDir&quot;:&quot;docs/_test-reporter/assets&quot;,&quot;jsonFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/docs/_test-reporter/mochawesome.json&quot;,&quot;htmlFile&quot;:&quot;/home/travis/build/RAN3D/foglet-core/docs/_test-reporter/mochawesome.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>