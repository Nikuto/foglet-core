{
  "stats": {
    "suites": 13,
    "tests": 28,
    "passes": 28,
    "pending": 0,
    "failures": 0,
    "start": "2018-10-02T11:54:45.163Z",
    "end": "2018-10-02T11:55:27.593Z",
    "duration": 42430,
    "testsRegistered": 28,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false,
    "passPercentClass": "success",
    "pendingPercentClass": "danger"
  },
  "suites": {
    "uuid": "5b3d3b37-719d-4b31-b3ca-3c0485467133",
    "title": "",
    "fullFile": "",
    "file": "",
    "beforeHooks": [],
    "afterHooks": [],
    "tests": [],
    "suites": [
      {
        "uuid": "b3b6df6b-2bde-476b-8c3b-8c385b15862f",
        "title": "Foglet High-level communication",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-communication-test.js",
        "file": "/tests/foglet-communication-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "should send messages to a neighbour using unicast",
            "fullTitle": "Foglet High-level communication should send messages to a neighbour using unicast",
            "timedOut": false,
            "duration": 2036,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf2.onUnicast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  assert.equal(message, 'hello')\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    console.log(peers)\n    assert.equal(peers.length, 1)\n    console.log(peers)\n    for (let i = 0; i < peers.length; i++) {\n      f1.sendUnicast(peers[i], 'hello')\n    }\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "e900c813-eea2-4725-b7d9-465133167564",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should send messages to several neighbours using multicast",
            "fullTitle": "Foglet High-level communication should send messages to several neighbours using multicast",
            "timedOut": false,
            "duration": 2011,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet wanted = 0\nlet received = 0\nfunction receive (id, message) {\n  received++\n  assert.equal(id, f1.outViewID)\n  assert.equal(message, 'hello')\n  if (received >= wanted) {\n    utils.clearFoglets(foglets).then(() => done())\n  }\n}\nf2.onUnicast(receive)\nf3.onUnicast(receive)\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(() => {\n    const peers = f1.getNeighbours()\n    wanted = peers.length\n    f1.sendMulticast(peers, 'hello')\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "f1a4b09b-a72b-425f-96b6-bcde3ca7c621",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should send messages to all peers using broadcast in a network with 2 peers",
            "fullTitle": "Foglet High-level communication should send messages to all peers using broadcast in a network with 2 peers",
            "timedOut": false,
            "duration": 2011,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nlet neighbourID = null\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf2.onBroadcast((id, data) => {\n  assert.equal(id, neighbourID)\n  assert.equal(data, 'hello')\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  neighbourID = f1.outViewID\n  setTimeout(function () {\n    f1.sendBroadcast('hello')\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "7f0b76b4-4f12-4cce-988c-16c9c21adb97",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should simply send messages to all peers using broadcast in a 3 peers network",
            "fullTitle": "Foglet High-level communication should simply send messages to all peers using broadcast in a 3 peers network",
            "timedOut": false,
            "duration": 2010,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet cptA = 0\nlet cptB = 0\nconst results = [ '1', '2', '3', '4' ]\nconst totalResult = 8\nconst check = utils.doneAfter(totalResult, () => {\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  f2.onBroadcast((id, message) => {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptA])\n    cptA++\n    check()\n  })\n  f3.onBroadcast((id, message) => {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptB])\n    cptB++\n    check()\n  })\n  setTimeout(() => {\n    f1.sendBroadcast('1')\n    f1.sendBroadcast('2')\n    f1.sendBroadcast('3')\n    f1.sendBroadcast('4')\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "4bf60181-3816-4493-8e53-ee0609c2632c",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should receive broadcasted classically ordered messages in a 3 peers network (1-2-3-4)",
            "fullTitle": "Foglet High-level communication should receive broadcasted classically ordered messages in a 3 peers network (1-2-3-4)",
            "timedOut": false,
            "duration": 2011,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet cptA = 0\nlet cptB = 0\nconst results = [ '1', '2', '3', '4' ]\nconst totalResult = 8\nconst check = utils.doneAfter(totalResult, () => {\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  f2.onBroadcast((id, message) => {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptA])\n    cptA++\n    check()\n  })\n  f3.onBroadcast((id, message) => {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptB])\n    cptB++\n    check()\n  })\n  setTimeout(() => {\n    const id1 = f1.overlay().communication.sendBroadcast('1')\n    const id2 = f1.overlay().communication.sendBroadcast('2', null, id1)\n    const id3 = f1.overlay().communication.sendBroadcast('3', null, id2)\n    f1.overlay().communication.sendBroadcast('4', null, id3)\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "6fd06173-0e86-460c-bf4d-543b7a6308fc",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should receive broadcasted weirdly ordered messages in a 3 peers network (1-3-2-4)",
            "fullTitle": "Foglet High-level communication should receive broadcasted weirdly ordered messages in a 3 peers network (1-3-2-4)",
            "timedOut": false,
            "duration": 4014,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet cptA = 0\nlet cptB = 0\nconst results = [ '1', '3', '2', '4' ]\nconst totalResult = 8\nconst check = utils.doneAfter(totalResult, () => {\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  f2.onBroadcast((id, message) => {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptA])\n    cptA++\n    check()\n  })\n  f3.onBroadcast((id, message) => {\n    assert.equal(id, f1.outViewID)\n    assert.equal(message, results[cptB])\n    cptB++\n    check()\n  })\n  setTimeout(() => {\n    const id1 = f1.overlay().communication.sendBroadcast('1')\n    const id2 = f1.overlay().communication.sendBroadcast('2', null, {e: id1.e, c: 3})\n    setTimeout(() => {\n      f1.overlay().communication.sendBroadcast('3', null, id1)\n      f1.overlay().communication.sendBroadcast('4', null, id2)\n    }, 2000)\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "f68bc7a7-5cfa-452d-b648-64a2a064dc6f",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "e900c813-eea2-4725-b7d9-465133167564",
          "f1a4b09b-a72b-425f-96b6-bcde3ca7c621",
          "7f0b76b4-4f12-4cce-988c-16c9c21adb97",
          "4bf60181-3816-4493-8e53-ee0609c2632c",
          "6fd06173-0e86-460c-bf4d-543b7a6308fc",
          "f68bc7a7-5cfa-452d-b648-64a2a064dc6f"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 14093,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "ace9dffe-7277-4ab4-8d41-30a578131f8b",
        "title": "[FOGLET] Other functions tests",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-main-test.js",
        "file": "/tests/foglet-main-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "[FOGLET] getRandomNeighbourId is in getNeighbours",
            "fullTitle": "[FOGLET] Other functions tests [FOGLET] getRandomNeighbourId is in getNeighbours",
            "timedOut": false,
            "duration": 9,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nutils.pathConnect(foglets, 2000).then(() => {\n  console.log('Peers: ', f1.getNeighbours(), f2.getNeighbours())\n  console.log('Random:', f1.getRandomNeighbourId(), f2.getRandomNeighbourId())\n  assert.include(f1.getNeighbours(), f1.getRandomNeighbourId())\n  utils.clearFoglets(foglets).then(() => done())\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "4ace3e65-9d98-43e0-8d09-51f93f46fb3a",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "4ace3e65-9d98-43e0-8d09-51f93f46fb3a"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 9,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "4ffc6d2b-841e-4cd7-b3b1-44885a4955bc",
        "title": "Middlewares",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-middleware-test.js",
        "file": "/tests/foglet-middleware-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "should use middleware on broadcast",
            "fullTitle": "Middlewares should use middleware on broadcast",
            "timedOut": false,
            "duration": 2019,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf1.use(simpleMiddleware)\nf2.use(simpleMiddleware)\nf2.onBroadcast((id, data) => {\n  assert.equal(data, 'So Long and Thanks for all the Fish')\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    f1.sendBroadcast('So Long')\n  }, 2000)\n})",
            "err": {},
            "isRoot": false,
            "uuid": "02c14afa-9b86-4e3b-aa07-a972696318b7",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should use middleware on unicast",
            "fullTitle": "Middlewares should use middleware on unicast",
            "timedOut": false,
            "duration": 2007,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf1.use(simpleMiddleware)\nf2.use(simpleMiddleware)\nf2.onUnicast((id, message) => {\n  assert.equal(message, 'So Long and Thanks for all the Fish')\n  utils.clearFoglets(foglets).then(() => done())\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    f1.sendUnicast(peers[0], 'So Long')\n  }, 2000)\n})",
            "err": {},
            "isRoot": false,
            "uuid": "b821c802-8522-4942-bd82-468d7f050919",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "02c14afa-9b86-4e3b-aa07-a972696318b7",
          "b821c802-8522-4942-bd82-468d7f050919"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 4026,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "b0d9ccae-e49d-457f-8c8e-ea2565b5d180",
        "title": "Overlays",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-overlay-test.js",
        "file": "/tests/foglet-overlay-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "should build a simple TMan-based overlay",
            "fullTitle": "Overlays should build a simple TMan-based overlay",
            "timedOut": false,
            "duration": 2078,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "done => {\n    const [ f1, f2 ] = utils.buildFog(Foglet, 2, [\n      {\n        name: 'test-overlay',\n        class: TestOverlay,\n        options: {\n          protocol: 'foglet-test-overlay',\n          signaling: {\n            room: 'foglet-test-overlay-room',\n            address: 'http://localhost:8000/'\n          }\n        }\n      }\n    ])\n    f1.overlay('test-overlay').communication.onUnicast((id, msg) => {\n      assert.equal(msg, 'hello world!')\n      console.log('Got message from: ', id, msg)\n      done()\n    })\n    utils.overlayConnect('test-overlay', 2000, f1, f2)\n      .then(() => {\n        setTimeout(() => {\n          const neighbours = f2.overlay('test-overlay').network.getNeighbours()\n          assert.equal(neighbours.length, 1)\n          f2.overlay('test-overlay').communication.sendUnicast(neighbours[0], 'hello world!')\n        }, 2000)\n      }).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "6fc84116-0d70-45cb-a5fa-966a40403c1e",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should create a internal communication channel correctly",
            "fullTitle": "Overlays should create a internal communication channel correctly",
            "timedOut": false,
            "duration": 2028,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "done => {\n    const [ f1, f2 ] = utils.buildFog(Foglet, 2, [\n      {\n        name: 'test-overlay-communication',\n        class: TestOverlay,\n        options: {\n          protocol: 'foglet-test-overlay-communication',\n          signaling: {\n            address: 'http://localhost:8000/',\n            room: 'foglet-test-overlay-communication-room'\n          }\n        }\n      }\n    ])\n    f1.overlay('test-overlay-communication').network.communication.onUnicast((id, msg) => {\n      assert.equal(msg, 'hello world!')\n      console.log('Got message from: ', id, msg)\n      done()\n    })\n    utils.overlayConnect('test-overlay-communication', 2000, f1, f2)\n      .then(() => {\n        setTimeout(() => {\n          const neighbours = f2.overlay('test-overlay-communication').network.getNeighbours()\n          assert.equal(neighbours.length, 1)\n          f2.overlay('test-overlay-communication').network.communication.sendUnicast(neighbours[0], 'hello world!')\n        }, 2000)\n      }).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "e961e6a9-a443-4066-a3b9-4ca13a88cf2e",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "6fc84116-0d70-45cb-a5fa-966a40403c1e",
          "e961e6a9-a443-4066-a3b9-4ca13a88cf2e"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 4106,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "0eb9dc01-8cda-4b8c-86fb-7395a32768c2",
        "title": "FogletProtocol",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
        "file": "/tests/foglet-protocol-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [],
        "suites": [
          {
            "uuid": "4746faaf-58e4-4424-8d33-b289345eb8d8",
            "title": "#unicast",
            "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
            "file": "/tests/foglet-protocol-test.js",
            "beforeHooks": [],
            "afterHooks": [],
            "tests": [],
            "suites": [
              {
                "uuid": "0c0e2743-ad5a-4ff8-9a37-9359bedece55",
                "title": "#communication",
                "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
                "file": "/tests/foglet-protocol-test.js",
                "beforeHooks": [],
                "afterHooks": [],
                "tests": [
                  {
                    "title": "should receive messages from remote services",
                    "fullTitle": "FogletProtocol #unicast #communication should receive messages from remote services",
                    "timedOut": false,
                    "duration": 1009,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const expected = 'Hello world!'\n        const p1 = new UnicastProtocol(f1)\n        const p2 = new UnicastProtocol(f2, (id, msg) => {\n          assert.equal(msg, expected)\n        }, () => {\n          utils.clearFoglets(foglets).then(() => done())\n        })\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], expected)\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "a27d62e2-6270-43c5-86ec-7cff62f49a9b",
                    "isHook": false,
                    "skipped": false
                  },
                  {
                    "title": "should allow peers to reply to service calls",
                    "fullTitle": "FogletProtocol #unicast #communication should allow peers to reply to service calls",
                    "timedOut": false,
                    "duration": 1012,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastProtocol(f1)\n        const p2 = new UnicastProtocol(f2, (id, msg, reply) => {\n          reply(msg + ' world!')\n        })\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], 'Hello')\n              .then(msg => {\n                assert.equal(msg, 'Hello world!')\n                utils.clearFoglets(foglets).then(() => done())\n              })\n              .catch(() => {\n                utils.clearFoglets(foglets).then(() => done())\n              })\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "dee4042f-7898-4b56-9fdc-3d9d4fbbbbe5",
                    "isHook": false,
                    "skipped": false
                  },
                  {
                    "title": "should allow peers to reject service calls",
                    "fullTitle": "FogletProtocol #unicast #communication should allow peers to reject service calls",
                    "timedOut": false,
                    "duration": 1005,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastProtocol(f1)\n        const p2 = new UnicastProtocol(f2, (id, msg, reply, reject) => {\n          reject(msg + ' world!')\n        })\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], 'Hello')\n              .then(msg => {\n                utils.clearFoglets(foglets).then(() => done(new Error('Message should have rejected but instead got reply with ' + msg)))\n              })\n              .catch(msg => {\n                assert.equal(msg, 'Hello world!')\n                utils.clearFoglets(foglets).then(() => done())\n              })\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "5a3d9c6e-4216-4f83-91a1-84d9ef518ed7",
                    "isHook": false,
                    "skipped": false
                  }
                ],
                "suites": [],
                "passes": [
                  "a27d62e2-6270-43c5-86ec-7cff62f49a9b",
                  "dee4042f-7898-4b56-9fdc-3d9d4fbbbbe5",
                  "5a3d9c6e-4216-4f83-91a1-84d9ef518ed7"
                ],
                "failures": [],
                "pending": [],
                "skipped": [],
                "duration": 3026,
                "root": false,
                "rootEmpty": false,
                "_timeout": 20000
              },
              {
                "uuid": "c2de0e2f-95db-49ba-b19b-36374d62d514",
                "title": "#hooks",
                "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
                "file": "/tests/foglet-protocol-test.js",
                "beforeHooks": [],
                "afterHooks": [],
                "tests": [
                  {
                    "title": "should allow before hooks on send & receive",
                    "fullTitle": "FogletProtocol #unicast #hooks should allow before hooks on send & receive",
                    "timedOut": false,
                    "duration": 1007,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        UnicastHookProtocol = defineProtocol('unicast-protocol-with-hooks')`\n          init\n          ${initProtocol}\n          get\n          ${function (service) {\n    service.is.unicast()\n    service.on.receive(function (id, msg) {\n      if (this._callback) this._callback(id, msg)\n      if (this._done) this._done()\n    })\n    service.before.send(function (msg) {\n      return msg + ' and Thanks for'\n    })\n    service.before.receive(function (msg) {\n      return msg + ' all the Fish'\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastHookProtocol(f1)\n        const p2 = new UnicastHookProtocol(f2, (id, msg) => {\n          assert.equal(msg, 'So Long and Thanks for all the Fish')\n        }, () => {\n          utils.clearFoglets(foglets).then(() => done())\n        })\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], 'So Long')\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "387f472b-7a81-46b4-aa91-26aba58c9ee4",
                    "isHook": false,
                    "skipped": false
                  },
                  {
                    "title": "should allow after hooks on send & receive",
                    "fullTitle": "FogletProtocol #unicast #hooks should allow after hooks on send & receive",
                    "timedOut": false,
                    "duration": 1007,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        const check = utils.doneAfter(2, () => {\n          utils.clearFoglets(foglets).then(() => done())\n        })\n        UnicastHookProtocol = defineProtocol('unicast-protocol-with-hooks')`\n          get\n          ${function (service) {\n    service.is.unicast()\n    service.on.receive(function () {})\n    service.after.send(function (msg) {\n      assert.equal(msg, 'So Long')\n      check()\n    })\n    service.after.receive(function (msg) {\n      assert.equal(msg, 'So Long')\n      check()\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new UnicastHookProtocol(f1)\n        const p2 = new UnicastHookProtocol(f2)\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get(peers[0], 'So Long')\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "0bb599bd-74d1-4b3b-aa59-ed51d10d0635",
                    "isHook": false,
                    "skipped": false
                  }
                ],
                "suites": [],
                "passes": [
                  "387f472b-7a81-46b4-aa91-26aba58c9ee4",
                  "0bb599bd-74d1-4b3b-aa59-ed51d10d0635"
                ],
                "failures": [],
                "pending": [],
                "skipped": [],
                "duration": 2014,
                "root": false,
                "rootEmpty": false,
                "_timeout": 20000
              }
            ],
            "passes": [],
            "failures": [],
            "pending": [],
            "skipped": [],
            "duration": 0,
            "root": false,
            "rootEmpty": false,
            "_timeout": 20000
          },
          {
            "uuid": "33af13da-420c-4848-a3f5-1df03a9540d1",
            "title": "#broadcast",
            "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
            "file": "/tests/foglet-protocol-test.js",
            "beforeHooks": [],
            "afterHooks": [],
            "tests": [],
            "suites": [
              {
                "uuid": "59a33fb0-fec8-4190-a60b-0859e84d401d",
                "title": "#communication",
                "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
                "file": "/tests/foglet-protocol-test.js",
                "beforeHooks": [],
                "afterHooks": [],
                "tests": [
                  {
                    "title": "should receive messages from remote services",
                    "fullTitle": "FogletProtocol #broadcast #communication should receive messages from remote services",
                    "timedOut": false,
                    "duration": 1007,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const expected = 'Hello world!'\n        const p1 = new BroadcastProtocol(f1)\n        const p2 = new BroadcastProtocol(f2, (id, msg) => {\n          assert.equal(msg, expected)\n        }, () => {\n          utils.clearFoglets(foglets).then(() => done())\n        })\n        utils.pathConnect(foglets, 2000).then(() => {\n          setTimeout(function () {\n            p1.get(expected)\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "d6ebb3b1-8b3b-4bec-b84b-d8f076c4cb3e",
                    "isHook": false,
                    "skipped": false
                  }
                ],
                "suites": [],
                "passes": [
                  "d6ebb3b1-8b3b-4bec-b84b-d8f076c4cb3e"
                ],
                "failures": [],
                "pending": [],
                "skipped": [],
                "duration": 1007,
                "root": false,
                "rootEmpty": false,
                "_timeout": 20000
              },
              {
                "uuid": "bb18fd95-d19b-4f71-b7d0-7b74329a4322",
                "title": "#hooks",
                "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-protocol-test.js",
                "file": "/tests/foglet-protocol-test.js",
                "beforeHooks": [],
                "afterHooks": [],
                "tests": [
                  {
                    "title": "should allow before hooks on send & receive",
                    "fullTitle": "FogletProtocol #broadcast #hooks should allow before hooks on send & receive",
                    "timedOut": false,
                    "duration": 1007,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        BroadcastHookProtocol = defineProtocol('broadcast-protocol-with-hooks')`\n          init\n          ${initProtocol}\n          get\n          ${function (service) {\n    service.is.broadcast()\n    service.on.receive(function (id, msg) {\n      if (this._callback) this._callback(id, msg)\n      if (this._done) this._done()\n    })\n    service.before.send(function (msg) {\n      return msg + ' and Thanks for'\n    })\n    service.before.receive(function (msg) {\n      return msg + ' all the Fish'\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new BroadcastHookProtocol(f1)\n        const p2 = new BroadcastHookProtocol(f2, (id, msg) => {\n          assert.equal(msg, 'So Long and Thanks for all the Fish')\n        }, () => {\n          utils.clearFoglets(foglets).then(() => done())\n        })\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get('So Long')\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "bfd4f2e8-d363-44df-9f72-c008853ff2f2",
                    "isHook": false,
                    "skipped": false
                  },
                  {
                    "title": "should allow after hooks on send & receive",
                    "fullTitle": "FogletProtocol #broadcast #hooks should allow after hooks on send & receive",
                    "timedOut": false,
                    "duration": 1007,
                    "state": "passed",
                    "speed": "slow",
                    "pass": true,
                    "fail": false,
                    "pending": false,
                    "code": "done => {\n        const check = utils.doneAfter(2, () => {\n          utils.clearFoglets(foglets).then(() => done())\n        })\n        BroadcastHookProtocol = defineProtocol('broadcast-protocol-with-hooks')`\n          get\n          ${function (service) {\n    service.is.broadcast()\n    service.on.receive(function () {})\n    service.after.send(function (msg) {\n      assert.equal(msg, 'So Long')\n      check()\n    })\n    service.after.receive(function (msg) {\n      assert.equal(msg, 'So Long')\n      check()\n    })\n  }}\n        `\n        const foglets = utils.buildFog(Foglet, 2)\n        const f1 = foglets[0]\n        const f2 = foglets[1]\n        const p1 = new BroadcastHookProtocol(f1)\n        const p2 = new BroadcastHookProtocol(f2)\n        utils.pathConnect(foglets, 2000, true).then(() => {\n          const peers = f1.getNeighbours()\n          assert.equal(peers.length, 1)\n          setTimeout(function () {\n            p1.get('So Long')\n          }, 1000)\n        })",
                    "err": {},
                    "isRoot": false,
                    "uuid": "97505827-0cc7-49ad-b886-b3c68613aa6f",
                    "isHook": false,
                    "skipped": false
                  }
                ],
                "suites": [],
                "passes": [
                  "bfd4f2e8-d363-44df-9f72-c008853ff2f2",
                  "97505827-0cc7-49ad-b886-b3c68613aa6f"
                ],
                "failures": [],
                "pending": [],
                "skipped": [],
                "duration": 2014,
                "root": false,
                "rootEmpty": false,
                "_timeout": 20000
              }
            ],
            "passes": [],
            "failures": [],
            "pending": [],
            "skipped": [],
            "duration": 0,
            "root": false,
            "rootEmpty": false,
            "_timeout": 20000
          }
        ],
        "passes": [],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 0,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "d01a4cb7-ae94-47a6-835b-bc6dd6494df2",
        "title": "[SIGNALING] Direct/Signaling connections",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-signaling-test.js",
        "file": "/tests/foglet-signaling-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "direct connection, return true when connected",
            "fullTitle": "[SIGNALING] Direct/Signaling connections direct connection, return true when connected",
            "timedOut": false,
            "duration": 6,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nutils.pathConnect(foglets, 2000).then((status) => {\n  assert.isOk(status, 'Status Must be true.')\n  utils.clearFoglets(foglets)\n  done()\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "5fdd2a9b-34fc-41cb-aada-742e23a3e79c",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "signaling connection alone, return true when connected",
            "fullTitle": "[SIGNALING] Direct/Signaling connections signaling connection alone, return true when connected",
            "timedOut": false,
            "duration": 8,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 1, [], [{ url: 'stun:global.stun.twilio.com:3478?transport=udp' }])\nconst f1 = foglets[0]\nf1.share()\nf1.connection().then((status) => {\n  assert.isOk(status, 'Status Must be true.')\n  utils.clearFoglets(foglets)\n  done()\n}).catch(e => {\n  done(e)\n})",
            "err": {},
            "isRoot": false,
            "uuid": "bf0368ba-44bc-4b8f-b17a-6a7cdc16a28e",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "signaling connection (2 peers network), return true when connected",
            "fullTitle": "[SIGNALING] Direct/Signaling connections signaling connection (2 peers network), return true when connected",
            "timedOut": false,
            "duration": 34,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2, [], [{ url: 'stun:global.stun.twilio.com:3478?transport=udp' }])\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf1.onUnicast((id, msg) => {\n  assert.equal(msg, 'ping')\n  utils.clearFoglets(foglets)\n  done()\n})\nf1.share()\nf1.connection().then((status) => {\n  f2.share()\n  assert.isOk(status, 'Status Must be true.')\n  f2.connection().then((status) => {\n    assert.isOk(status, 'Status Must be true.')\n    assert.equal(f2.getNeighbours().length, 1)\n    f2.sendUnicast(f2.getNeighbours()[0], 'ping')\n  }).catch(done)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "b641ba70-9b47-4ba9-8774-63c0f8db2758",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "5fdd2a9b-34fc-41cb-aada-742e23a3e79c",
          "bf0368ba-44bc-4b8f-b17a-6a7cdc16a28e",
          "b641ba70-9b47-4ba9-8774-63c0f8db2758"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 48,
        "root": false,
        "rootEmpty": false,
        "_timeout": 20000
      },
      {
        "uuid": "70af4eca-df9c-4db5-b667-e1a93bcbff2b",
        "title": "Foglet streaming communication",
        "fullFile": "/home/travis/build/RAN3D/foglet-core/tests/foglet-streams-test.js",
        "file": "/tests/foglet-streams-test.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "should stream data to a neighbour using unicast",
            "fullTitle": "Foglet streaming communication should stream data to a neighbour using unicast",
            "timedOut": false,
            "duration": 2018,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nlet acc = ''\nf2.onStreamUnicast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('data', data => { acc += data })\n  message.on('end', () => {\n    assert.equal(acc, 'Hello world!Family!')\n    utils.clearFoglets(foglets)\n    done()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    const stream = f1.streamUnicast(peers[0])\n    stream.write('Hello ')\n    stream.write('world!')\n    stream.write('Family!')\n    stream.end()\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "5c84eeda-f498-4097-96cc-452e373d3ff8",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should stream trailing data to a neighbour using unicast",
            "fullTitle": "Foglet streaming communication should stream trailing data to a neighbour using unicast",
            "timedOut": false,
            "duration": 2005,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nf2.onStreamUnicast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('data', () => null)\n  message.on('end', () => {\n    assert.equal(message.trailers.length, 1)\n    assert.equal(message.trailers[0], 'Hello world!Family!')\n    utils.clearFoglets(foglets)\n    done()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    const stream = f1.streamUnicast(peers[0])\n    stream.write('foo')\n    stream.addTrailer('Hello world!Family!')\n    stream.end()\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "7b05d01b-f403-4d01-a5e8-c9b348f42085",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should transmit an error through a stream when using unicast",
            "fullTitle": "Foglet streaming communication should transmit an error through a stream when using unicast",
            "timedOut": false,
            "duration": 2007,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst check = utils.doneAfter(2, () => {\n  utils.clearFoglets(foglets)\n  done()\n})\nf2.onStreamUnicast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('error', err => {\n    assert.equal(err, 'Everything goes wrong!')\n    check()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    const peers = f1.getNeighbours()\n    assert.equal(peers.length, 1)\n    const stream = f1.streamUnicast(peers[0])\n    stream.on('error', () => check())\n    stream.destroy('Everything goes wrong!')\n    stream.end()\n  }, 2000)\n})",
            "err": {},
            "isRoot": false,
            "uuid": "40b5616e-0e92-4df1-9768-929e42448c41",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should stream data to all peers using broadcast in a network with 2 peers",
            "fullTitle": "Foglet streaming communication should stream data to all peers using broadcast in a network with 2 peers",
            "timedOut": false,
            "duration": 2009,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 2)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nlet acc = ''\nf2.onStreamBroadcast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('data', data => { acc += data })\n  message.on('end', () => {\n    assert.equal(acc, 'Hello world!Family!')\n    utils.clearFoglets(foglets)\n    done()\n  })\n})\nutils.pathConnect(foglets, 2000).then(() => {\n  setTimeout(function () {\n    const stream = f1.streamBroadcast()\n    stream.write('Hello ')\n    stream.write('world!')\n    stream.write('Family!')\n    stream.end()\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "797ae6bb-da1a-4120-9a6e-2dbab89654a8",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should stream data to all peers using broadcast in a network with 3 peers",
            "fullTitle": "Foglet streaming communication should stream data to all peers using broadcast in a network with 3 peers",
            "timedOut": false,
            "duration": 2010,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nlet accA = ''\nlet accB = ''\nconst check = utils.doneAfter(2, () => {\n  utils.clearFoglets(foglets)\n  done()\n})\nf2.onStreamBroadcast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('data', data => { accA += data })\n  message.on('end', () => {\n    assert.equal(accA, 'Hello world!Family!')\n    check()\n  })\n})\nf3.onStreamBroadcast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('data', data => { accB += data })\n  message.on('end', () => {\n    assert.equal(accB, 'Hello world!Family!')\n    check()\n  })\n})\nutils.pathConnect(foglets, 1000).then(() => {\n  setTimeout(function () {\n    const stream = f1.streamBroadcast()\n    stream.write('Hello ')\n    stream.write('world!')\n    stream.write('Family!')\n    stream.end()\n  }, 2000)\n}).catch(done)",
            "err": {},
            "isRoot": false,
            "uuid": "dd2e38e0-bf36-4de0-8c8d-83732e3ab60a",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should transmit an error through a stream when using broadcast",
            "fullTitle": "Foglet streaming communication should transmit an error through a stream when using broadcast",
            "timedOut": false,
            "duration": 2012,
            "state": "passed",
            "speed": "slow",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "const foglets = utils.buildFog(Foglet, 3)\nconst f1 = foglets[0]\nconst f2 = foglets[1]\nconst f3 = foglets[2]\nconst check = utils.doneAfter(3, () => {\n  utils.clearFoglets(foglets)\n  done()\n})\nf2.onStreamBroadcast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('error', err => {\n    assert.equal(err, 'Everything goes wrong!')\n    check()\n  })\n})\nf3.onStreamBroadcast((id, message) => {\n  assert.equal(id, f1.outViewID)\n  message.on('error', err => {\n    assert.equal(err, 'Everything goes wrong!')\n    check()\n  })\n})\nutils.pathConnect(foglets, 1000).then(() => {\n  setTimeout(function () {\n    const stream = f1.streamBroadcast()\n    stream.on('error', () => check())\n    stream.destroy('Everything goes wrong!')\n    stream.end()\n  }, 2000)\n})",
            "err": {},
            "isRoot": false,
            "uuid": "701df076-39be-47ac-9595-8f1e44b18f99",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "5c84eeda-f498-4097-96cc-452e373d3ff8",
          "7b05d01b-f403-4d01-a5e8-c9b348f42085",
          "40b5616e-0e92-4df1-9768-929e42448c41",
          "797ae6bb-da1a-4120-9a6e-2dbab89654a8",
          "dd2e38e0-bf36-4de0-8c8d-83732e3ab60a",
          "701df076-39be-47ac-9595-8f1e44b18f99"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 12061,
        "root": false,
        "rootEmpty": false,
        "_timeout": 30000
      }
    ],
    "passes": [],
    "failures": [],
    "pending": [],
    "skipped": [],
    "duration": 0,
    "root": true,
    "rootEmpty": true,
    "_timeout": 30000
  },
  "copyrightYear": 2018
}