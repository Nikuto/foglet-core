<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Spray example</title>
  </head>

  <body>
    Please: Open the console!
  </body>

  <script src='../../dist/foglet.bundle.js'></script>
  <script src='/p2p-graph/p2p-graph.min.js'></script>
  <p> Theoretical number of arcs: ~<span id="theoretical"></span> <br/>
    Actual number of duplicates: <span id="actualdup"></span><br/>
    Actual number of arcs without duplicates: <span id="actualwodup"></span><br/>
    Pourcentage of duplicate: <span id="actualpourcentage"></span><br/>
    Average PV size: <span id="pv"></span><br/>
    Actual number of pending entries: <span id="pending"></span></p>
  <div class="graph" width=800 height=600></div>
  <script type='text/javascript'>
    console.log(foglet)
    localStorage.debug = 'foglet-core:*, spa'
    let graph = new window.P2PGraph('.graph');
    let revertedIndex = new Map();
    const max = 10
    const spray_a = 1, spray_b = 5
    document.getElementById("theoretical").innerHTML = ""+ (max* (spray_a*Math.log(max) + spray_b));
    let apps = []
    for(let i = 0; i<(max); i++) {
      const fog = createApp(i)
      apps.push(fog)
      graph.add({
          id: fog.id,
          me: false,
          name: 'C-'+i
      });
      fog.overlay().network.rps.on('open', (peerId) => {
        console.log('[%s] Peer id: ', fog.id,  peerId)
          !graph.hasLink(fog.id, revertedIndex.get(peerId)) &&
              graph.connect(fog.id, revertedIndex.get(peerId));
      });
      fog.overlay().network.rps.on('close', (peerId) => {
          (!fog.overlay().network.rps.o.has(peerId)) &&
              graph.disconnect(fog.id, revertedIndex.get(peerId));
      });
      revertedIndex.set(fog.inViewID, fog.id);
    }

    const loaded = []
    apps.reduce((acc, fog) => acc.then(() => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          let chosen = Math.floor(Math.random() * loaded.length)
          //chosen = loaded.length - 1
          if(loaded.length === 0)  {
            chosen = Math.floor(Math.random() * apps.length)
            // fog.connection(apps[chosen]).then(() => {
            //   loaded.push(fog)
            //   resolve()
            // }).catch(e => {
            //   resolve()
            // })
            loaded.push(fog)
            resolve()
          } else {
            fog.connection(loaded[chosen]).then(() => {
              loaded.push(fog)
              resolve()
            }).catch(e => {
              resolve()
            })
          }
        }, 1000)
      })
    }), Promise.resolve())



    function createApp(id) {
      console.log(id)
      const fog = new foglet.Foglet({
        id: 'C-'+id,
        verbose: true, // want some logs ? switch to false otherwise
        rps: {
          options : {
            a: spray_a, b: spray_b,
            delta: 30 * 1000,
            timeout: 30 * 1000,
            pendingTimeout: 30 * 1000,
            socketClass: foglet.SimplePeerMoc
          }
        }
      })
      fog.onUnicast((id, message) => {
        console.log(`${fog.id} received a unicasted message from ${id}: `, message)
      })
      fog.onBroadcast((id, message) => {
        console.log(`${fog.id} received a broadcasted message from ${id}: `, message)
      })
      return fog
    }

    setInterval(() => {
      const withoutduplicates = apps.reduce((acc, cur) => acc+cur.overlay().network.rps.partialView.size, 0)
      const numberofduplicates = apps.reduce((acc, cur) => {
        return acc+[...cur.overlay().network.rps.partialView].reduce((a, c) => {
          return c[1].length
        }, 0)
      }, 0)
      const pv = apps.reduce((acc, cur) => acc+cur.overlay().network.rps.partialView.size, 0)/apps.length
      document.getElementById("actualdup").innerHTML = ""+ numberofduplicates;
      document.getElementById("actualwodup").innerHTML = ""+ withoutduplicates;
      document.getElementById("actualpourcentage").innerHTML = ""+ numberofduplicates / withoutduplicates * 100 + '%';
      document.getElementById("pv").innerHTML = ""+ pv + " / "+ (spray_a*Math.log(max) + spray_b);
      document.getElementById("pending").innerHTML = ""+ apps.reduce((acc, cur) => acc+cur.overlay().network.rps.NI.pending.size+cur.overlay().network.rps.NO.pending.size, 0);
    }, 2000)



    let scramblecount = 0
    let scramble = (delay = 0) => {
        scramblecount++
        for (let i = 0; i < max; ++i) {
            setTimeout ( (nth) => {
                apps[nth].overlay().network.rps._exchange(); // force exchange
                if(i === max-1) {
                  const average = apps.reduce((acc, cur) => acc+cur.getNeighbours().length, 0) / apps.length
                  console.log('Round: %f, averagepv=%f', scramblecount, average)
                  document.getElementById("pending").innerHTML = ""+ apps.reduce((acc, cur) => acc+cur.overlay().network.rps.NI.pending.size+cur.overlay().network.rps.NO.pending.size, 0);
                }
            }, i*delay, i);
        };
        // setInterval(() => {
        //   scramble(500)
        // }, 10000)
    };

  </script>
</html>
